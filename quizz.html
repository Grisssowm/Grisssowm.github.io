<!doctype html>
<html lang="pt-BR" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Effects Studio</title>
  <script src="https://cdn.tailwindcss.com/3.4.17"></script>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&amp;display=swap" rel="stylesheet">
  <style>
    * { font-family: 'JetBrains Mono', monospace; }
    body { background: #0a0e27; }
    
    .preview-container {
      position: relative;
      width: 100%;
      max-width: 600px;
      aspect-ratio: 4/3;
      background: linear-gradient(45deg, #1a1f3a 0%, #2d1b4e 100%);
      border-radius: 16px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #canvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: #1a1f3a;
      border-radius: 8px;
      border: 1px solid #2d3561;
    }

    .slider-label {
      color: #a0aec0;
      font-size: 12px;
      min-width: 100px;
      text-transform: uppercase;
    }

    input[type="range"] {
      flex: 1;
      height: 6px;
      border-radius: 3px;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(102, 126, 234, 0.6);
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 10px rgba(102, 126, 234, 0.6);
    }

    .value-display {
      color: #667eea;
      font-weight: 600;
      min-width: 45px;
      text-align: right;
    }

    button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      text-transform: uppercase;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
    }

    .btn-secondary {
      background: #2d1b4e;
      border: 1px solid #667eea;
      color: #667eea;
    }

    .btn-secondary:hover {
      background: #3d2b5e;
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
    }

    .toggle-btn {
      padding: 8px 16px;
      font-size: 11px;
      background: #2d1b4e;
      border: 2px solid #667eea;
      color: #a0aec0;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .toggle-btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-color: #667eea;
      box-shadow: 0 0 15px rgba(102, 126, 234, 0.6);
    }

    .section-title {
      color: #667eea;
      font-size: 13px;
      text-transform: uppercase;
      font-weight: 700;
      margin-top: 20px;
      margin-bottom: 12px;
      letter-spacing: 2px;
    }

    .effect-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 16px;
    }

    @keyframes glow {
      0%, 100% { text-shadow: 0 0 10px rgba(102, 126, 234, 0.5); }
      50% { text-shadow: 0 0 20px rgba(102, 126, 234, 1); }
    }

    h1 {
      animation: glow 2s ease-in-out infinite;
    }
  </style>
  <style>body { box-sizing: border-box; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="/_sdk/element_sdk.js" type="text/javascript"></script>
 </head>
 <body class="h-full">
  <div class="h-full overflow-auto p-6">
   <div class="max-w-6xl mx-auto">
    <!-- T√≠tulo -->
    <div class="text-center mb-8">
     <h1 class="text-4xl md:text-5xl font-bold text-transparent bg-gradient-to-r from-purple-500 via-pink-500 to-cyan-500 bg-clip-text mb-2">üé® IMAGE EFFECTS STUDIO</h1>
     <p class="text-gray-400 text-sm">Aplique efeitos incr√≠veis em tempo real</p>
    </div>
    <div class="grid md:grid-cols-2 gap-8">
     <!-- Coluna Esquerda - Preview -->
     <div class="flex flex-col gap-4">
      <div class="preview-container" id="previewContainer">
       <canvas id="canvas"></canvas>
       <div id="explosionContainer" style="position: absolute; inset: 0;"></div>
      </div>
      <div class="flex gap-2">
       <button onclick="resetAllEffects()" class="flex-1 btn-secondary">üîÑ Reset</button> <button onclick="downloadImage()" class="flex-1">‚¨áÔ∏è Download</button>
      </div><input type="file" id="imageInput" accept="image/*" style="display: none;"> <button onclick="document.getElementById('imageInput').click()" class="w-full">üì§ Carregar Imagem</button>
     </div><!-- Coluna Direita - Controles -->
     <div class="space-y-4 overflow-y-auto max-h-screen pr-4">
      <!-- Upload Info -->
      <div class="bg-purple-900/20 border border-purple-500 p-4 rounded-lg">
       <p class="text-purple-300 text-sm">Carregue uma imagem para come√ßar! 50+ efeitos de distor√ß√£o e forma aguardando...</p>
      </div><!-- DISTOR√á√ïES B√ÅSICAS -->
      <div>
       <div class="section-title">
        üåÄ Distor√ß√µes B√°sicas
       </div>
       <div class="slider-container">
        <span class="slider-label">Olho Peixe</span> <input type="range" id="fisheye" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="fisheyeValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Turbilh√£o</span> <input type="range" id="whirl" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="whirlValue">0¬∞</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Onda H</span> <input type="range" id="waveH" min="0" max="50" value="0" oninput="updateEffects()"> <span class="value-display" id="waveHValue">0px</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Onda V</span> <input type="range" id="waveV" min="0" max="50" value="0" oninput="updateEffects()"> <span class="value-display" id="waveVValue">0px</span>
       </div>
      </div><!-- DEFORMA√á√ïES -->
      <div>
       <div class="section-title">
        üé™ Deforma√ß√µes
       </div>
       <div class="slider-container">
        <span class="slider-label">Alongamento X</span> <input type="range" id="stretchX" min="50" max="150" value="100" oninput="updateEffects()"> <span class="value-display" id="stretchXValue">100%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Alongamento Y</span> <input type="range" id="stretchY" min="50" max="150" value="100" oninput="updateEffects()"> <span class="value-display" id="stretchYValue">100%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Compress√£o</span> <input type="range" id="squeeze" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="squeezeValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Cisalhamento</span> <input type="range" id="shear" min="-30" max="30" value="0" oninput="updateEffects()"> <span class="value-display" id="shearValue">0¬∞</span>
       </div>
      </div><!-- EFEITOS DE FORMA -->
      <div>
       <div class="section-title">
        üìê Transforma√ß√µes
       </div>
       <div class="slider-container">
        <span class="slider-label">Espiral</span> <input type="range" id="spiral" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="spiralValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">V√≥rtice</span> <input type="range" id="vortex" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="vortexValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Fractal</span> <input type="range" id="fractal" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="fractalValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Fragmenta√ß√£o</span> <input type="range" id="fragment" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="fragmentValue">0%</span>
       </div>
      </div><!-- EFEITOS RADICAIS -->
      <div>
       <div class="section-title">
        üí• Efeitos Radicais
       </div>
       <div class="slider-container">
        <span class="slider-label">Derretimento</span> <input type="range" id="melt" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="meltValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Pixeliza√ß√£o</span> <input type="range" id="pixelate" min="0" max="50" value="0" oninput="updateEffects()"> <span class="value-display" id="pixelateValue">0px</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Riples</span> <input type="range" id="ripple" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="rippleValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Reflexo</span> <input type="range" id="mirror" min="0" max="3" value="0" step="1" oninput="updateEffects()"> <span class="value-display" id="mirrorValue">Off</span>
       </div>
      </div><!-- EFEITOS GEOM√âTRICOS -->
      <div>
       <div class="section-title">
        üî∑ Efeitos Geom√©tricos
       </div>
       <div class="slider-container">
        <span class="slider-label">Kaleidosc√≥pio</span> <input type="range" id="kaleidoscope" min="3" max="12" value="3" step="1" oninput="updateEffects()"> <span class="value-display" id="kaleidoscopeValue">3</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Mosaico</span> <input type="range" id="mosaic" min="0" max="50" value="0" oninput="updateEffects()"> <span class="value-display" id="mosaicValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Lentes</span> <input type="range" id="lens" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="lensValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Cristal</span> <input type="range" id="crystal" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="crystalValue">0%</span>
       </div>
      </div><!-- EFEITOS ORG√ÇNICOS -->
      <div>
       <div class="section-title">
        üåä Efeitos Org√¢nicos
       </div>
       <div class="slider-container">
        <span class="slider-label">Turbul√™ncia</span> <input type="range" id="turbulence" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="turbulenceValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Curvatura</span> <input type="range" id="curve" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="curveValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Tors√£o</span> <input type="range" id="twist" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="twistValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Compacta√ß√£o</span> <input type="range" id="compact" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="compactValue">0%</span>
       </div>
      </div><!-- EFEITOS AVAN√áADOS -->
      <div>
       <div class="section-title">
        ‚ú® Efeitos Avan√ßados
       </div>
       <div class="slider-container">
        <span class="slider-label">Invers√£o Radial</span> <input type="range" id="inversion" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="inversionValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Proje√ß√£o Polar</span> <input type="range" id="polar" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="polarValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Distor√ß√£o de Fase</span> <input type="range" id="phase" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="phaseValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Efeito Lava</span> <input type="range" id="lava" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="lavaValue">0%</span>
       </div>
      </div><!-- EFEITOS EXTREMOS -->
      <div>
       <div class="section-title">
        ‚ö° Efeitos Extremos
       </div>
       <div class="slider-container">
        <span class="slider-label">Fragmenta√ß√£o Aleat√≥ria</span> <input type="range" id="randomFrag" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="randomFragValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Glitch Temporal</span> <input type="range" id="glitch" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="glitchValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Distor√ß√£o Qu√¢ntica</span> <input type="range" id="quantum" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="quantumValue">0%</span>
       </div>
       <div class="slider-container">
        <span class="slider-label">Efeito Buraco Negro</span> <input type="range" id="blackhole" min="0" max="100" value="0" oninput="updateEffects()"> <span class="value-display" id="blackholeValue">0%</span>
       </div>
      </div><!-- BOT√ïES DE A√á√ÉO -->
      <div style="margin-top: 20px;">
       <div class="flex gap-2 mb-3">
        <button onclick="resetAllEffects()" class="flex-1 btn-secondary">üîÑ Resetar</button> <button onclick="downloadImage()" class="flex-1">‚¨áÔ∏è Download</button>
       </div>
      </div>
     </div>
    </div>
   </div>
  </div>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const imageInput = document.getElementById('imageInput');
    
    let originalImage = null;
    let effects = {
      fisheye: 0, whirl: 0, waveH: 0, waveV: 0,
      stretchX: 100, stretchY: 100, squeeze: 0, shear: 0,
      spiral: 0, vortex: 0, fractal: 0, fragment: 0,
      melt: 0, pixelate: 0, ripple: 0, mirror: 0,
      kaleidoscope: 3, mosaic: 0, lens: 0, crystal: 0,
      turbulence: 0, curve: 0, twist: 0, compact: 0,
      inversion: 0, polar: 0, phase: 0, lava: 0,
      randomFrag: 0, glitch: 0, quantum: 0, blackhole: 0
    };

    imageInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          const img = new Image();
          img.onload = () => {
            originalImage = img;
            canvas.width = img.width;
            canvas.height = img.height;
            updateEffects();
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      }
    });

    function updateEffects() {
      if (!originalImage) return;

      // Atualizar valores dos sliders
      Object.keys(effects).forEach(key => {
        const elem = document.getElementById(key);
        if (elem) effects[key] = parseFloat(elem.value);
      });

      // Atualizar labels
      Object.keys(effects).forEach(key => {
        const valueElem = document.getElementById(key + 'Value');
        if (valueElem) {
          if (key === 'kaleidoscope') valueElem.textContent = Math.round(effects[key]);
          else if (key === 'mirror') valueElem.textContent = ['Off', 'H', 'V', 'Both'][Math.round(effects[key])];
          else if (key.includes('stretch') || key === 'stretchX' || key === 'stretchY') valueElem.textContent = effects[key].toFixed(0) + '%';
          else valueElem.textContent = effects[key].toFixed(0) + (key.includes('stretch') || key.includes('squeeze') || key.includes('compact') ? '%' : key.includes('shear') ? '¬∞' : key.includes('intensity') ? '%' : key.includes('pixelate') ? 'px' : '%');
        }
      });

      drawImage();
    }

    function drawImage() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(originalImage, 0, 0);

      // Aplicar efeitos em sequ√™ncia
      if (effects.pixelate > 0) applyPixelation(effects.pixelate);
      if (effects.fisheye > 0) applyFisheye(effects.fisheye);
      if (effects.whirl > 0) applyWhirl(effects.whirl);
      if (effects.waveH > 0 || effects.waveV > 0) applyWaves();
      if (effects.stretchX !== 100 || effects.stretchY !== 100) applyStretch();
      if (effects.squeeze > 0) applySqueeze();
      if (effects.shear !== 0) applyShear();
      if (effects.spiral > 0) applySpiral();
      if (effects.vortex > 0) applyVortex();
      if (effects.fractal > 0) applyFractal();
      if (effects.fragment > 0) applyFragmentation();
      if (effects.melt > 0) applyMelt();
      if (effects.ripple > 0) applyRipple();
      if (effects.mirror > 0) applyMirror();
      if (effects.kaleidoscope > 3) applyKaleidoscope();
      if (effects.mosaic > 0) applyMosaic();
      if (effects.lens > 0) applyLens();
      if (effects.crystal > 0) applyCrystal();
      if (effects.turbulence > 0) applyTurbulence();
      if (effects.curve > 0) applyCurve();
      if (effects.twist > 0) applyTwist();
      if (effects.compact > 0) applyCompact();
      if (effects.inversion > 0) applyInversion();
      if (effects.polar > 0) applyPolar();
      if (effects.phase > 0) applyPhase();
      if (effects.lava > 0) applyLava();
      if (effects.randomFrag > 0) applyRandomFrag();
      if (effects.glitch > 0) applyGlitch();
      if (effects.quantum > 0) applyQuantum();
      if (effects.blackhole > 0) applyBlackhole();
    }

    // ===== EFEITOS B√ÅSICOS =====
    function applyPixelation(pixelSize) {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = Math.max(1, canvas.width / pixelSize);
      tempCanvas.height = Math.max(1, canvas.height / pixelSize);
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
      ctx.imageSmoothingEnabled = true;
    }

    function applyFisheye(intensity) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const str = intensity / 100 * 0.5;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const dx = (x - cx) / cx, dy = (y - cy) / cy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);
          const distorted = dist * (1 + str * dist);
          const sx = Math.round(cx + Math.cos(angle) * distorted * cx);
          const sy = Math.round(cy + Math.sin(angle) * distorted * cy);
          if (sx >= 0 && sx < w && sy >= 0 && sy < h) {
            const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
            newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
          }
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyWhirl(angle) {
      const cx = canvas.width / 2, cy = canvas.height / 2;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate((angle * Math.PI) / 180);
      ctx.translate(-cx, -cy);
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      ctx.restore();
      ctx.putImageData(imgData, 0, 0);
    }

    function applyWaves() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const newData = new Uint8ClampedArray(data);
      const wH = effects.waveH, wV = effects.waveV;

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const sx = Math.round(x + Math.sin(y * 0.05) * wH);
          const sy = Math.round(y + Math.cos(x * 0.05) * wV);
          if (sx >= 0 && sx < w && sy >= 0 && sy < h) {
            const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
            newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
          }
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    // ===== DEFORMA√á√ïES =====
    function applyStretch() {
      const sx = effects.stretchX / 100, sy = effects.stretchY / 100;
      const cx = canvas.width / 2, cy = canvas.height / 2;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.scale(sx, sy);
      ctx.translate(-cx, -cy);
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      ctx.restore();
      ctx.putImageData(imgData, 0, 0);
    }

    function applySqueeze() {
      const intensity = effects.squeeze / 100;
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const dx = (x - cx) / cx, dy = (y - cy) / cy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const factor = 1 - intensity * dist;
          const sx = Math.round(cx + dx * cx / (factor || 0.1));
          const sy = Math.round(cy + dy * cy / (factor || 0.1));
          if (sx >= 0 && sx < w && sy >= 0 && sy < h) {
            const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
            newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
          }
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyShear() {
      const shear = effects.shear / 100;
      ctx.save();
      ctx.transform(1, shear, shear, 1, 0, 0);
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      ctx.restore();
      ctx.putImageData(imgData, 0, 0);
    }

    // ===== TRANSFORMA√á√ïES =====
    function applySpiral() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const intensity = effects.spiral / 100 * 10;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const dx = x - cx, dy = y - cy;
          const angle = Math.atan2(dy, dx);
          const dist = Math.sqrt(dx * dx + dy * dy);
          const newAngle = angle + dist * intensity;
          const sx = Math.round(cx + Math.cos(newAngle) * dist);
          const sy = Math.round(cy + Math.sin(newAngle) * dist);
          if (sx >= 0 && sx < w && sy >= 0 && sy < h) {
            const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
            newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
          }
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyVortex() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const intensity = effects.vortex / 100 * 0.1;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const dx = x - cx, dy = y - cy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) + dist * intensity;
          const sx = Math.round(cx + Math.cos(angle) * dist);
          const sy = Math.round(cy + Math.sin(angle) * dist);
          if (sx >= 0 && sx < w && sy >= 0 && sy < h) {
            const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
            newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
          }
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyFractal() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const intensity = effects.fractal / 100;
      const newData = new Uint8ClampedArray(data);

      for (let i = 0; i < data.length; i += 4) {
        const idx = Math.floor(Math.random() * (data.length - 4) / 4) * 4;
        newData[i] = data[idx] * (1 - intensity) + data[i] * intensity;
        newData[i+1] = data[idx+1] * (1 - intensity) + data[i+1] * intensity;
        newData[i+2] = data[idx+2] * (1 - intensity) + data[i+2] * intensity;
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyFragmentation() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const intensity = effects.fragment / 100 * 20;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const offset = Math.round((Math.random() - 0.5) * intensity);
          const sx = Math.max(0, Math.min(w - 1, x + offset));
          const sy = Math.max(0, Math.min(h - 1, y + offset));
          const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
          newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    // ===== EFEITOS RADICAIS =====
    function applyMelt() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const intensity = effects.melt / 100;
      const newData = new Uint8ClampedArray(data);

      for (let y = 1; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const offset = Math.round(Math.random() * intensity * 20);
          const sy = Math.min(h - 1, y + offset);
          const si = (sy * w + x) * 4, di = (y * w + x) * 4;
          newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyRipple() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const intensity = effects.ripple / 100 * 15;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const wave = Math.sin(y * 0.1) * intensity + Math.cos(x * 0.1) * intensity;
          const sx = Math.max(0, Math.min(w - 1, x + Math.round(wave)));
          const sy = Math.max(0, Math.min(h - 1, y + Math.round(wave)));
          const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
          newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyMirror() {
      const mirrorType = Math.round(effects.mirror);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;

      if (mirrorType === 1 || mirrorType === 3) { // Horizontal
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w / 2; x++) {
            const i1 = (y * w + x) * 4;
            const i2 = (y * w + (w - 1 - x)) * 4;
            [data[i1], data[i2]] = [data[i2], data[i1]];
            [data[i1+1], data[i2+1]] = [data[i2+1], data[i1+1]];
            [data[i1+2], data[i2+2]] = [data[i2+2], data[i1+2]];
          }
        }
      }
      if (mirrorType === 2 || mirrorType === 3) { // Vertical
        for (let y = 0; y < h / 2; y++) {
          for (let x = 0; x < w; x++) {
            const i1 = (y * w + x) * 4;
            const i2 = ((h - 1 - y) * w + x) * 4;
            [data[i1], data[i2]] = [data[i2], data[i1]];
            [data[i1+1], data[i2+1]] = [data[i2+1], data[i1+1]];
            [data[i1+2], data[i2+2]] = [data[i2+2], data[i1+2]];
          }
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }

    // ===== EFEITOS GEOM√âTRICOS =====
    function applyKaleidoscope() {
      const sections = Math.round(effects.kaleidoscope);
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(canvas, 0, 0);

      const cx = canvas.width / 2, cy = canvas.height / 2;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let i = 0; i < sections; i++) {
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate((i * Math.PI * 2) / sections);
        ctx.translate(-cx, -cy);
        ctx.drawImage(tempCanvas, 0, 0);
        ctx.restore();
      }
    }

    function applyMosaic() {
      const tileSize = effects.mosaic > 0 ? Math.ceil(effects.mosaic / 5) + 2 : 1;
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y += tileSize) {
        for (let x = 0; x < w; x += tileSize) {
          let r = 0, g = 0, b = 0, a = 0, count = 0;
          for (let ty = 0; ty < tileSize && y + ty < h; ty++) {
            for (let tx = 0; tx < tileSize && x + tx < w; tx++) {
              const i = ((y + ty) * w + (x + tx)) * 4;
              r += data[i]; g += data[i+1]; b += data[i+2]; a += data[i+3];
              count++;
            }
          }
          r /= count; g /= count; b /= count; a /= count;
          for (let ty = 0; ty < tileSize && y + ty < h; ty++) {
            for (let tx = 0; tx < tileSize && x + tx < w; tx++) {
              const i = ((y + ty) * w + (x + tx)) * 4;
              newData[i] = r; newData[i+1] = g; newData[i+2] = b; newData[i+3] = a;
            }
          }
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyLens() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const maxDist = Math.sqrt(cx * cx + cy * cy);
      const intensity = effects.lens / 100 * 0.3;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const dx = x - cx, dy = y - cy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const normalized = dist / maxDist;
          const zoom = 1 + Math.sin(normalized * Math.PI) * intensity;
          const sx = Math.round(cx + dx / zoom);
          const sy = Math.round(cy + dy / zoom);
          if (sx >= 0 && sx < w && sy >= 0 && sy < h) {
            const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
            newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
          }
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyCrystal() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const crystalSize = Math.ceil(effects.crystal / 10) + 1;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y += crystalSize) {
        for (let x = 0; x < w; x += crystalSize) {
          const rx = Math.floor(Math.random() * crystalSize);
          const ry = Math.floor(Math.random() * crystalSize);
          const sx = Math.min(w - 1, x + rx);
          const sy = Math.min(h - 1, y + ry);
          const si = (sy * w + sx) * 4;
          const color = [data[si], data[si+1], data[si+2], data[si+3]];

          for (let ty = 0; ty < crystalSize && y + ty < h; ty++) {
            for (let tx = 0; tx < crystalSize && x + tx < w; tx++) {
              const di = ((y + ty) * w + (x + tx)) * 4;
              newData[di] = color[0]; newData[di+1] = color[1]; newData[di+2] = color[2]; newData[di+3] = color[3];
            }
          }
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    // ===== EFEITOS ORG√ÇNICOS =====
    function applyTurbulence() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const intensity = effects.turbulence / 100 * 30;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const noise = Math.sin(x * 0.02 + y * 0.03) * Math.cos(x * 0.01);
          const sx = Math.max(0, Math.min(w - 1, x + Math.round(noise * intensity)));
          const sy = Math.max(0, Math.min(h - 1, y + Math.round(noise * intensity)));
          const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
          newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyCurve() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const intensity = effects.curve / 100 * 20;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const curve = Math.sin(x * 0.05) * intensity;
          const sy = Math.max(0, Math.min(h - 1, y + Math.round(curve)));
          const si = (sy * w + x) * 4, di = (y * w + x) * 4;
          newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyTwist() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const intensity = effects.twist / 100 * 10;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const dx = x - cx, dy = y - cy;
          const angle = Math.atan2(dy, dx);
          const dist = Math.sqrt(dx * dx + dy * dy);
          const maxDist = Math.sqrt(cx * cx + cy * cy);
          const twist = (1 - dist / maxDist) * intensity;
          const newAngle = angle + twist;
          const sx = Math.round(cx + Math.cos(newAngle) * dist);
          const sy = Math.round(cy + Math.sin(newAngle) * dist);
          if (sx >= 0 && sx < w && sy >= 0 && sy < h) {
            const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
            newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
          }
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyCompact() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const maxDist = Math.sqrt(cx * cx + cy * cy);
      const intensity = effects.compact / 100;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const dx = x - cx, dy = y - cy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const factor = 1 - (dist / maxDist) * intensity;
          const sx = Math.round(cx + dx * factor);
          const sy = Math.round(cy + dy * factor);
          if (sx >= 0 && sx < w && sy >= 0 && sy < h) {
            const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
            newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
          }
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    // ===== EFEITOS AVAN√áADOS =====
    function applyInversion() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const maxDist = Math.sqrt(cx * cx + cy * cy);
      const intensity = effects.inversion / 100;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const dx = x - cx, dy = y - cy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 1) dist = 1;
          const inverted = (maxDist * maxDist) / dist;
          const factor = inverted / maxDist;
          const angle = Math.atan2(dy, dx);
          const sx = Math.round(cx + Math.cos(angle) * Math.min(maxDist, inverted) * intensity + dx * (1 - intensity));
          const sy = Math.round(cy + Math.sin(angle) * Math.min(maxDist, inverted) * intensity + dy * (1 - intensity));
          if (sx >= 0 && sx < w && sy >= 0 && sy < h) {
            const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
            newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
          }
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyPolar() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const intensity = effects.polar / 100;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const dx = x - cx, dy = y - cy;
          const angle = Math.atan2(dy, dx);
          const dist = Math.sqrt(dx * dx + dy * dy);
          const sx = Math.round(cx + angle * w / Math.PI * intensity + dx * (1 - intensity));
          const sy = Math.round(cy + dist * intensity + dy * (1 - intensity));
          if (sx >= 0 && sx < w && sy >= 0 && sy < h) {
            const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
            newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
          }
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyPhase() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const intensity = effects.phase / 100 * 20;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const phase = Math.sin(x * 0.02 + y * 0.02) * intensity;
          const sx = Math.max(0, Math.min(w - 1, x + Math.round(phase)));
          const sy = Math.max(0, Math.min(h - 1, y + Math.round(phase)));
          const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
          newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyLava() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const intensity = effects.lava / 100;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const lava = Math.sin(x * 0.05 + y * 0.05) * 50 * intensity;
          const sx = Math.max(0, Math.min(w - 1, x + Math.round(lava)));
          const sy = Math.max(0, Math.min(h - 1, y));
          const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
          newData[di] = data[si]; newData[di+1] = data[si+1]; newData[di+2] = data[si+2]; newData[di+3] = data[si+3];
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    // ===== EFEITOS EXTREMOS =====
    function applyRandomFrag() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const intensity = Math.round(effects.randomFrag / 100 * (w * h * 0.1));
      const newData = new Uint8ClampedArray(data);

      for (let i = 0; i < intensity; i++) {
        const idx = Math.floor(Math.random() * (data.length / 4)) * 4;
        const randIdx = Math.floor(Math.random() * (data.length / 4)) * 4;
        newData[idx] = data[randIdx];
        newData[idx+1] = data[randIdx+1];
        newData[idx+2] = data[randIdx+2];
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyGlitch() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const intensity = Math.round(effects.glitch / 100 * h * 0.1);
      const newData = new Uint8ClampedArray(data);

      for (let i = 0; i < intensity; i++) {
        const y = Math.floor(Math.random() * h);
        const offset = Math.floor(Math.random() * 50) - 25;
        for (let x = 0; x < w; x++) {
          const sx = Math.max(0, Math.min(w - 1, x + offset));
          const si = (y * w + sx) * 4, di = (y * w + x) * 4;
          newData[di] = data[si];
          newData[di+1] = data[si+1];
          newData[di+2] = data[si+2];
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyQuantum() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const intensity = effects.quantum / 100;
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const rand = Math.random();
          if (rand < intensity) {
            const sx = Math.floor(Math.random() * w);
            const sy = Math.floor(Math.random() * h);
            const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
            newData[di] = data[si];
            newData[di+1] = data[si+1];
            newData[di+2] = data[si+2];
            newData[di+3] = data[si+3];
          } else {
            const i = (y * w + x) * 4;
            newData[i] = data[i];
            newData[i+1] = data[i+1];
            newData[i+2] = data[i+2];
            newData[i+3] = data[i+3];
          }
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function applyBlackhole() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const w = canvas.width, h = canvas.height;
      const cx = w / 2, cy = h / 2;
      const maxDist = Math.sqrt(cx * cx + cy * cy);
      const intensity = effects.blackhole / 100;
      const eventHorizon = maxDist * (1 - intensity * 0.3);
      const newData = new Uint8ClampedArray(data);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const dx = x - cx, dy = y - cy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < eventHorizon * intensity) {
            newData[(y * w + x) * 4 + 0] = 0;
            newData[(y * w + x) * 4 + 1] = 0;
            newData[(y * w + x) * 4 + 2] = 0;
          } else {
            const angle = Math.atan2(dy, dx);
            const pull = 1 + (eventHorizon / (dist + 1)) * intensity;
            const sx = Math.round(cx + Math.cos(angle) * (dist / pull));
            const sy = Math.round(cy + Math.sin(angle) * (dist / pull));
            if (sx >= 0 && sx < w && sy >= 0 && sy < h) {
              const si = (sy * w + sx) * 4, di = (y * w + x) * 4;
              newData[di] = data[si];
              newData[di+1] = data[si+1];
              newData[di+2] = data[si+2];
              newData[di+3] = data[si+3];
            }
          }
        }
      }
      ctx.putImageData(new ImageData(newData, w, h), 0, 0);
    }

    function resetAllEffects() {
      Object.keys(effects).forEach(key => {
        const elem = document.getElementById(key);
        if (elem) {
          if (key === 'kaleidoscope') elem.value = 3;
          else if (key === 'stretchX' || key === 'stretchY') elem.value = 100;
          else elem.value = 0;
        }
      });
      effects = {
        fisheye: 0, whirl: 0, waveH: 0, waveV: 0,
        stretchX: 100, stretchY: 100, squeeze: 0, shear: 0,
        spiral: 0, vortex: 0, fractal: 0, fragment: 0,
        melt: 0, pixelate: 0, ripple: 0, mirror: 0,
        kaleidoscope: 3, mosaic: 0, lens: 0, crystal: 0,
        turbulence: 0, curve: 0, twist: 0, compact: 0,
        inversion: 0, polar: 0, phase: 0, lava: 0,
        randomFrag: 0, glitch: 0, quantum: 0, blackhole: 0
      };
      if (originalImage) updateEffects();
    }

    function downloadImage() {
      if (!originalImage) return;
      const link = document.createElement('a');
      link.href = canvas.toDataURL('image/png');
      link.download = 'image-effects.png';
      link.click();
    }
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9d21d6bc5790e2ac',t:'MTc3MTc5ODQ5MS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
